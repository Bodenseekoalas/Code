#pragma config(Sensor, S2,     ,               sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          A,             tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          B,             tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          C,             tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h"
tHTIRS2 Seeker_P;
#include "hitechnic-compass.h"
tHTMC Kompass_P;


#include "mindsensors-ev3smux.h"

tMSEV3 muxedSensor[3];

tEV3SensorTypeMode typeMode[3] = {sonarCM, sonarCM, sonarCM};

//Enistellungs Variablen
int FieldWidth = 121   -10;
int FieldHeight = 181  -10;
int Speed_A = 70 ;
int Speed_D = 70 ;
int Speed_B = 100 ;
int Drib_Norm = 170 ;
int Kord_Num = 3;

// System Variablen
bool motor_deturn=false;
int LTd=5;
int Seeker ;
int Kompass ;
int Drib_Speed ;
int Offset_Heading ;
string  status  ;
int Distanz_seite = 0;
int Distanz_vorne = 0;
int Distanz_seite2 = 0;
int sizeOfWidthFields = round(FieldWidth / Kord_Num);
int sizeOfHeightFields = round(FieldHeight / Kord_Num);
int FieldX;
int FieldY;
int X_Speed;
int Y_Speed;
int Position;
int motor_sets;
int returner;
int lastXPos;
int lastYPos;
int Ballturn;
int lastturndirection=1;
bool korektionturn=true;
string Direktion;
int timer ;
int KompAusrichten;
int Komp_Offdrive_komplete;
int Komp_Offdrive;
int Kompass1;
int Kompass2;

/*
Sensoren:
port 1: Kompass
port 2: Ultraschall MUX
port 3: leer
port 4: Ballsuche

Motore:
port A: rechter Motor
port B: Dribbler
port C: leer
port D: linker Motor
*/
//Zum Tor Drehen f?r Radar

void  Read_Sensors(){
	//gibt true zur?ck falls es geklappt hat und false falls nicht
	readSensor (&Seeker_P);
	readSensor (&Kompass_P);

	readSensor(&muxedSensor[0]);
	readSensor(&muxedSensor[1]);
	readSensor(&muxedSensor[2]);

	Distanz_seite = round(muxedSensor[1].distance/10;
	Distanz_vorne = round(muxedSensor[0].distance/10;
	Distanz_seite2 = round(muxedSensor[2].distance/10;

	Drib_Speed = getMotorRPM(motorB);

	Seeker = Seeker_P.acDirection;
	Kompass = Kompass_P.relativeHeading;

	displayBigTextLine   (1,"seeker: %d",Seeker);
	displayBigTextLine   (3,"Komp: %d",Kompass);
	displayBigTextLine   (5,"Komp_Off: %d",Komp_Offdrive);
	displayBigTextLine   (7,"seite2: %d",Distanz_seite2);
	displayBigTextLine   (9,"seite : %d",Distanz_seite);
	displayBigTextLine   (11,"vorn : %d",Distanz_vorne);
	displayBigTextLine   (13,"Dribb.: %d",Drib_Speed);
}

void Motor (int x,int y){
	setMotorSpeed  (motorA,x);
	setMotorSpeed  (motorD,y);
}

void BallGot(){
	//if (KompAusrichten==true){
	if ((Kompass<20)&&(Kompass>-20)){
		if ((Distanz_seite<24)&&(Distanz_vorne<24)){
			Motor(-10,10);
			delay(650);
			Motor(30,30);
			delay(1500);
			Motor(0,0);
			motor_deturn=false;
		}
		else if ((Distanz_seite2<24)&&(Distanz_vorne<24)){
			Motor(10,-10);
			delay(650);
			Motor(30,30);
			delay(1500);
			Motor(0,0);
			motor_deturn=false;
		}
		else if ((Distanz_seite2>20)&&(Distanz_vorne>20)&&((Distanz_seite>20)&&(Distanz_vorne>20))){
			Motor(Speed_A,Speed_D);
			motor_deturn = true ;
		}
		playImmediateTone(400, 5);
	}
	else {
		Motor(-20,20);
		motor_deturn=false;
	}
}

void Ballserch(int xsek){
	KompAusrichten=true;
	if (xsek==0){
		Motor((Speed_A/2),-(Speed_D/4));
	}
	else if (Seeker>0){
		if (xsek==4){
			lastturndirection=1;
			korektionturn = false;
			Motor(-(Speed_A/8),(Speed_D/8));
		}
		else if (xsek==6){
			lastturndirection=2;
			korektionturn = false;
			Motor((Speed_A/8),-(Speed_D/8));
		}
		else if (xsek<4){
			lastturndirection=1;
			korektionturn = false;
			Motor(-(Speed_A/4),(Speed_D/4));
		}
		else if (xsek>6){
			lastturndirection=2;
			korektionturn = false;
			Motor((Speed_A/4),-(Speed_D/4));
		}
		else  if (xsek==5){
			if (korektionturn == false) {
				if (lastturndirection == 2){
					Motor(20,-30);
					wait1Msec(200);
					Motor(0,0);
				}
				else if (lastturndirection == 1){
					Motor(-30,20);
					wait1Msec(200);
					Motor(0,0);
				}
				korektionturn = true;
			}
			else{
				Motor(Speed_A,Speed_D);
			}
		}
	}
}

void  Main_Switch () {

	if (Drib_Speed >= Drib_Norm){
		status = "Ball";
		Ballserch(Seeker);
		motor_deturn=false;
	}
	else if ( Drib_Speed > 0) {
		status = "Tor";
		BallGot();
	}
}

task main (){
	initSensor(&muxedSensor[0], msensor_S2_1, typeMode[0]);
	initSensor(&muxedSensor[1], msensor_S2_2, typeMode[1]);
	initSensor(&muxedSensor[2], msensor_S2_3, typeMode[2]);
	initSensor (&Seeker_P, S4);
	initSensor (&Kompass_P, S3);

	setMotorSpeed(motorB,Speed_B);

	readSensor (&Kompass_P);
	Offset_Heading = Kompass_P.Heading;
	Kompass_P.offset = Offset_Heading;

	Motor(100,100);

	//wait1Msec(600);

	while (true ){
		if (motor_deturn==false){
			setMotorSpeed(motorB,Speed_B);
		}
		else {
			setMotorSpeed(motorB,-Speed_B);
		}
		Read_Sensors();
		Main_Switch();
		wait1Msec(5);
	}
}
